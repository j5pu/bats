#!/usr/bin/env bash

set -eu
shopt -s inherit_errexit

. "${0}.sh"

#######################################
# show error and exit 1
# Arguments:
#   * message
#######################################
die() { >&2 echo "${script}: ${*}"; exit 1; }

#######################################
# show help and exit
# Arguments:
#   None
#######################################
help() {
  local rc=$?
  [ ! "${1-}" ] || echo -e "${script}: ${1}: invalid argument/test path\n"
  cat <<EOF
usage: ${script} [<tests>] [<options>]
   or: ${script} -h|-help|commands|help|functions|verbose
   or: . ${script%.*}.sh

bats testing wrapper and helper functions when "${script%.*}.sh" sourced

<tests> is the path to a Bats test file, or the path to a directory containing Bats test files (ending with ".bats")
if no <tests> run for: first directory found with ".bats" files in working directory,
or either 'tests', 'test' or '__tests__' under top repository path

Changes to top repository path \$SHTS_TOP when running testa and top path found, otherwise changes to the \$SHTS_TESTS

Commands:
   -h, --help, help  display this help and exit
   commands          display ${script}' commands
   functions         display functions available when ${script} is sourced
   list              display tests found relative to current working directory

Options:
   --dry-run         show command that would be executed and globals
   --one             run only one job in parallel instead of \$BATS_NUMBER_OF_PARALLEL_JOBS
   --verbose         run bats tests showing all outputs, with trace and not cleaning the tempdir

Globals:
   SHTS_OUTPUT      verbose output directory
   SHTS_TESTS       path to the test directory, passed as argument or found by 'shts'
EOF
  exit $rc
}

#######################################
# find tests in directory "*.bats" and ".shts"
# Globals:
#   OPTS_BACK
# Arguments:
#   None
# Returns:
#  1 if not tests found or argument is not a directory
#######################################
tests() {
  test -d "$1" || return
  mapfile -t TESTS < <(find "$(realpath "$1")" \( -type f -o -type l \) \( -name "*.bats" -o -name "*.shts" \)) \
    && [ "${TESTS-}" ];
}

#######################################
# parse arguments when is executed and run bats  (private used by bats.bash)
# Globals:
#   OPTS_BACK
# Arguments:
#   None
#######################################
main() {
  script="${0##*/}"
  local args=(--print-output-on-failure) jobs=()
  local directory dry=false list=false output="${SHTS_TOP:-.}/.output"

  rm -rf "${output}"

  for arg; do
    case "${arg}" in
      -h|--help|help) help ;;
      --dry-run) dry=true ;;
      --one) unset BATS_NUMBER_OF_PARALLEL_JOBS ;;
      --verbose) args+=(--gather-test-outputs-in "${output}" --no-tempdir-cleanup --output "${output}" \
        --show-output-of-passing-tests --timing --trace --verbose-run) ;;
      commands) printf '%s\n' -h --help help "${arg}" functions list| sort; exit ;;
      functions) "${0}.sh" "${arg}"; exit ;;
      list) list=true ;;
      *)
        { test -f "${arg}" && [[ "${arg##*.}" =~ bats|shts ]] && directory="$(dirname "${arg}")" \
          && TESTS=("$(realpath "${arg}")"); } || tests "${arg}" || help "${arg}"
        directory="$(realpath "${directory:-${arg}}")"
        ;;
    esac
  done

  jobs=(--jobs "${BATS_NUMBER_OF_PARALLEL_JOBS:-1}")

  if [ ! "${TESTS-}" ]; then
    if tests "$(pwd)"; then
      directory="$(pwd)"
    elif [ "${SHTS_TOP-}" ]; then
      for i in tests test __tests__; do
        directory="${SHTS_TOP}/${i}"
        ! tests "${directory}" || break
      done
      [ "${TESTS-}" ] || die "${PWD}: no bats/shts test found"
    else
      die "${PWD}: not a git repository (or any of the parent directories)"
    fi
  fi

  if $list; then
    printarr "${TESTS[@]}" | sed "s|$(pwd)/||"
  elif $dry; then
    echo SHTS_OUTPUT="${output}" SHTS_TESTS="$(realpath "${directory}")" bats "${TESTS[@]}" "${jobs[@]}" "${args[@]}"
  else
    SHTS_OUTPUT="${output}" SHTS_TESTS="$(realpath "${directory}")" bats "${TESTS[@]}" "${jobs[@]}" "${args[@]}"
  fi
}

main "$@"
